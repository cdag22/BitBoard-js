var __extends=this&&this.__extends||function(){var extendStatics=function(d,b){extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b}||function(d,b){for(var p in b)if(b.hasOwnProperty(p))d[p]=b[p]};return extendStatics(d,b)};return function(d,b){extendStatics(d,b);function __(){this.constructor=d}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __)}}();(function(factory){if(typeof module==="object"&&typeof module.exports==="object"){var v=factory(require,exports);if(v!==undefined)module.exports=v}else if(typeof define==="function"&&define.amd){define(["require","exports"],factory)}})(function(require,exports){"use strict";var BitBoard=function(){function BitBoard(board){var _this=this;this.MAX_BITS=4294967296;this.BITS_PER_BUCKET=32;this.length=64;this.board;if(board){if(!Array.isArray(board)||board.some(function(x){return typeof x!=="number"})){throw new TypeError("board must be an array")}else if(board.length!==2||board.some(function(x){return Math.floor(x)!==x||x<0||x>=_this.MAX_BITS})){throw new RangeError("inputs to board array must be two integers x where  0 <= x < 2 ^ 32 (or 4294967296)")}this.board=board}else{this.board=[0,0]}}BitBoard.prototype.determineIfBitBoard=function(bb){var _this=this;var names=Object.getOwnPropertyNames(bb);var doPrototypesMatch=Object.getPrototypeOf(bb)===BitBoard.prototype;var arePropertyNamesCorrect=names.every(function(name){return["board","length","BITS_PER_BUCKET","MAX_BITS"].indexOf(name)!==-1});var isBoardLengthCorrect=bb.board&&bb.board.length===2&&bb.length===this.length;var isBoardArrayCorrect=Array.isArray(bb.board)&&bb.board.every(function(n){return typeof n==="number"&&n>=0&&n<_this.MAX_BITS&&Math.floor(n)===n});return arePropertyNamesCorrect&&isBoardLengthCorrect&&isBoardArrayCorrect&&doPrototypesMatch};BitBoard.prototype.toString=function(){var str="";for(var i=0;i<this.board.length;i++){str+=padString((this.board[i]>>>0).toString(2),this.BITS_PER_BUCKET,"0",true)}return str};BitBoard.prototype.getIndex=function(index){if(Math.floor(index)===index&&index>=0&&index<this.length){var powOfTwo=Math.pow(2,index%this.BITS_PER_BUCKET);var bucketOffset=index>this.BITS_PER_BUCKET?1:0;return(this.board[1-bucketOffset]&powOfTwo)>>>0>0?1:0}throw new RangeError("index must be integer greater than or equal to 0 and less than 64")};BitBoard.prototype.copy=function(){return new BitBoard(this.board.slice())};BitBoard.prototype.isEmpty=function(){return this.board[0]===0&&this.board[1]===0};BitBoard.prototype.and=function(bb,modify){if(modify===void 0){modify=false}if(this.determineIfBitBoard(bb)){var newBoard=modify?this:this.copy();for(var i=0;i<this.board.length;i++){newBoard.board[i]=(newBoard.board[i]&bb.board[i])>>>0}return newBoard}throw new TypeError("Invalid input. Must be of type BitBoard")};BitBoard.prototype.or=function(bb,modify){if(modify===void 0){modify=false}if(this.determineIfBitBoard(bb)){var newBoard=modify?this:this.copy();for(var i=0;i<this.board.length;i++){newBoard.board[i]=(newBoard.board[i]|bb.board[i])>>>0}return newBoard}throw new TypeError('Invalid input. Must be of type "BitBoard" or "number"')};BitBoard.prototype.xOr=function(bb,modify){if(modify===void 0){modify=false}if(this.determineIfBitBoard(bb)){var newBoard=modify?this:this.copy();for(var i=0;i<this.board.length;i++){newBoard.board[i]=(newBoard.board[i]^bb.board[i])>>>0}return newBoard}throw new TypeError('Invalid input. Must be of type "BitBoard" or "number"')};BitBoard.prototype.orNumber=function(shiftAmount,num,modify){if(shiftAmount===void 0){shiftAmount=0}if(num===void 0){num=1}if(modify===void 0){modify=false}if(typeof shiftAmount==="number"&&typeof num==="number"){if(shiftAmount>=0&&shiftAmount<this.length&&num>=0&&num<this.MAX_BITS){var newBoard=modify?this:this.copy();var startDigits=(num<<shiftAmount>>>0&Math.pow(2,32)-1)>>>0;var startDigitMask=(startDigits&Math.pow(2,32)-1)>>>0;var numCarryDigits=num>>>32-shiftAmount>>>0;if(shiftAmount===32){newBoard.board[0]=(newBoard.board[0]|num)>>>0}else if(shiftAmount===0){newBoard.board[1]=(newBoard.board[1]|startDigitMask)>>>0}else if(shiftAmount>32&&shiftAmount<64){newBoard.board[0]=(newBoard.board[0]|startDigitMask)>>>0}else{newBoard.board[1]=(newBoard.board[1]|startDigitMask)>>>0;newBoard.board[0]=(newBoard.board[0]|numCarryDigits)>>>0}return newBoard}throw new RangeError("0 <= shiftAmount < 64 && 0 <= num <= 2 ^ 32 - 1")}throw new TypeError("Invalid input. Must be of type number")};BitBoard.prototype.xOrNumber=function(shiftAmount,num,modify){if(shiftAmount===void 0){shiftAmount=0}if(num===void 0){num=1}if(modify===void 0){modify=false}if(typeof shiftAmount==="number"&&typeof num==="number"){if(shiftAmount>=0&&shiftAmount<this.length&&num>=0&&num<this.MAX_BITS){var newBoard=modify?this:this.copy();var startDigits=(num<<shiftAmount>>>0&Math.pow(2,32)-1)>>>0;var startDigitMask=(startDigits&Math.pow(2,32)-1)>>>0;var numCarryDigits=num>>>32-shiftAmount>>>0;if(shiftAmount===32){newBoard.board[0]=(newBoard.board[0]^num)>>>0}else if(shiftAmount===0){newBoard.board[1]=(newBoard.board[1]^startDigitMask)>>>0}else if(shiftAmount>32){newBoard.board[0]=(newBoard.board[0]^startDigitMask)>>>0}else{newBoard.board[1]=(newBoard.board[1]^startDigitMask)>>>0;newBoard.board[0]=(newBoard.board[0]^numCarryDigits)>>>0}return newBoard}throw new RangeError("0 <= shiftAmount < 64 && 0 <= num <= 2 ^ 32 - 1")}throw new TypeError("Invalid input. Must be of type number")};BitBoard.prototype.not=function(modify){if(modify===void 0){modify=false}var newBoard=modify?this:this.copy();for(var i=0;i<newBoard.board.length;i++){newBoard.board[i]=~newBoard.board[i]>>>0}return newBoard};BitBoard.prototype.shiftLeft=function(shiftAmount,modify){if(modify===void 0){modify=false}if(typeof shiftAmount==="number"){if(shiftAmount>=0){var newBoard=modify?this:this.copy();var bitMask=Math.pow(2,shiftAmount)-1<<this.BITS_PER_BUCKET-shiftAmount>>>0;var carryDigits=(newBoard.board[1]&bitMask)>>>0>>>this.BITS_PER_BUCKET-shiftAmount;if(shiftAmount===this.BITS_PER_BUCKET){newBoard.board[1]=0;newBoard.board[0]=carryDigits}else if(shiftAmount>this.BITS_PER_BUCKET&&shiftAmount<this.length){newBoard.board[0]=newBoard.board[1]<<shiftAmount-this.BITS_PER_BUCKET>>>0;newBoard.board[1]=0}else if(shiftAmount>=this.length){newBoard.board[0]=0;newBoard.board[1]=0}else{newBoard.board[1]=newBoard.board[1]<<shiftAmount>>>0;newBoard.board[0]=(newBoard.board[0]<<shiftAmount>>>0|carryDigits)>>>0}return newBoard}throw new RangeError("Invalid input. index must be >= 0")}throw new TypeError('Invalid input. Must be "number"')};BitBoard.prototype.shiftRight=function(shiftAmount,modify){if(modify===void 0){modify=false}if(typeof shiftAmount==="number"){if(shiftAmount>=0){var newBoard=modify?this:this.copy();var bitMask=Math.pow(2,shiftAmount)-1<<this.BITS_PER_BUCKET-shiftAmount>>>0;var carryDigits=(newBoard.board[0]<<this.BITS_PER_BUCKET-shiftAmount>>>0&bitMask)>>>0;if(shiftAmount===this.BITS_PER_BUCKET){newBoard.board[0]=0;newBoard.board[1]=carryDigits}else if(shiftAmount>this.BITS_PER_BUCKET&&shiftAmount<this.length){newBoard.board[1]=newBoard.board[0]>>>shiftAmount-this.BITS_PER_BUCKET>>>0;newBoard.board[0]=0}else if(shiftAmount>=this.length){newBoard.board[0]=0;newBoard.board[1]=0}else{newBoard.board[0]=newBoard.board[0]>>>shiftAmount>>>0;newBoard.board[1]=(newBoard.board[1]>>>shiftAmount|carryDigits)>>>0}return newBoard}throw new RangeError("Invalid input. index must be >= 0")}throw new TypeError('Invalid input. Must be "number"')};return BitBoard}();function padString(str,length,padValue,start){if(start){for(var i=str.length;i<length;i++){str=padValue+str}}else{for(var i=str.length;i<length;i++){str+=padValue}}return str}var ChessBitBoard=function(_super){__extends(ChessBitBoard,_super);function ChessBitBoard(input){var _this=this;if(input&&input.boardType){switch(input.boardType){case"piece":_this=_super.call(this,[4294901760,65535])||this;break;case"black":input.lsb==="a1"?_this=_super.call(this,[4294901760,0])||this:_this=_super.call(this,[0,65535])||this;break;case"white":input.lsb==="a1"?_this=_super.call(this,[0,65535])||this:_this=_super.call(this,[4294901760,0])||this;break;case"pawn":_this=_super.call(this,[16711680,65280])||this;break;case"knight":_this=_super.call(this,[1107296256,66])||this;break;case"bishop":_this=_super.call(this,[603979776,36])||this;break;case"rook":_this=_super.call(this,[2164260864,129])||this;break;case"queen":_this=_super.call(this,[268435456,16])||this;break;case"king":_this=_super.call(this,[134217728,8])||this;break;default:throw new SyntaxError('Input is not a valid value for boardType. Must be one of the following:\n\t"black", "white", "piece", "pawn", "knight", "bishop", "rook", "queen", "king"')}}else if(input&&input.board){_this=_super.call(this,input.board)||this}else{_this=_super.call(this)||this}return _this}return ChessBitBoard}(BitBoard);var ConnectFourBitBoard=function(_super){__extends(ConnectFourBitBoard,_super);function ConnectFourBitBoard(board){if(board===void 0){board=[0,0]}return _super.call(this,board)||this}ConnectFourBitBoard.isWin=function(bb){var directions=[1,7,6,8];for(var _i=0,directions_1=directions;_i<directions_1.length;_i++){var direction=directions_1[_i];var firstShift=bb.shiftRight(2*direction);var secondShift=bb.shiftRight(3*direction);var result=bb.and(bb.shiftRight(direction)).and(firstShift).and(secondShift);if(!result.isEmpty())return true}return false};return ConnectFourBitBoard}(BitBoard);var Board={BitBoard:BitBoard,ChessBitBoard:ChessBitBoard,ConnectFourBitBoard:ConnectFourBitBoard};return Board});
